Beniffits of tail recursion optimizations is the most obvious on method ecixutions that  would otherwise run out of stack space. Considder for example the following program.

It recursevly incremetst i untill i overflows to 0 and returns the result.
\begin{lstlisting}
class OverflowPlease {
  def makeZero( i:Int):Int = {
    if (i==0){
      i
    }else{
      this.makeZero(i+1)
    }
  }
}

object Main extends App {
  println(new OverflowPlease().makeZero(0))
}


\end{lstlisting}
each recursion creates a new stack fram, so a stack that fits over 4 million frames would be requiered to execute this program. But with tailrecursion optimization we expect this program to Sucessfully overflow i to 0 only using a couple of stack frams.

This should also make the programs that do not run out of stack space faster since poping and pushing stack frames is a relatively slow procidure.


here is a similar example from the lab descrption that recursively get the last element of a linked list

\begin{lstlisting}
class Helper {
  def last(a: List): List = {
    if (a.hasNext()) {
      this.last(a.next())
    } else {
      a
    }
  }
}
\end{lstlisting}

\subsection{Recursion on trees}

Recursion on tree structures is interesting because in binary tries we need to recurse on the left and right subtrees, but only the one of the recursive calls may be in the tail position. Still removing one of the recursive calls is better then non, especially if the tree tends to be unbalanced.

this example has a function that tail recursively sums the contents of the tree.

and enother one that sets all the contents of the tree to 0.

\begin{lstlisting}
class TreeHelper {
  def countNodes(a: Tree, acc: Int): List = {
    val r:Tree = NULL;
    val l:Tree = NULL;
    val sum:Int = acc;
    if(a==NULL){
        sum
    }else{
      r=a.getRight();
      l=a.getLeft();
      sum = this.countNodes(r, acc) + sum + 1;
      this.countNodes(l, sum)
    }
  }
  
  def cleanseTree(a: Tree): List = {
    val r:Tree = NULL;
    val l:Tree = NULL;
    if(!(a==NULL)){
      a.setValue(0);
      r=a.getRight();
      l=a.getLeft();
      this.cleanseTree(r);
      this.cleanseTree(l)
    }
  }
}
\end{lstlisting}

\subsection{corecursive tail calls}
\label{sec:corecursionexample}

Here is toy example of the more general problem that we do not inted to handle. Here two methods \texttt{isEven(Int)} and \texttt{isOdd(Int)} use tail calls to each other to determin if the input method is odd or even.

\begin{lstlisting}
class numbers {
  def isEven(i:Int):Boolean = {
    if(i==0) True
    else     isOdd(i-1)
  }
  
  def isOdd(i:Int):Boolean = {
    if(i==1) True
    else     isEven(i-1)
  }
  
}
\end{lstlisting}

